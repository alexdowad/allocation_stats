Introduction
============

ObjectSpace Stats is a rubygem that makes use of Ruby 2.1's new abilities to trace
Ruby object allocations (MRI only). Ruby 2.1's new
`ObjectSpace.trace_object_allocations` method gives only raw information, and is
not immediately useful for anything beyond micro profiling. The data must be
aggregated!

ObjectSpace Stats collects all of the allocation information generated by
`ObjectSpace.trace_object_allocations`, then provides mechanisms for filtering,
grouping, and sorting the allocation information.

Tabular Output examples
-----------------------

It is very easy to get some simple statistics out of ObjectSpace Stats.
Wrap some code with `ObjectSpace::Stats.new` and print out a listing of all of the
new object allocation information.

As an example, lets look at `examples/my_class.rb`:

```ruby
class MyClass
  def my_method
    @hash = {1 => "foo", 2 => "bar"}
  end
end
```

And use that class in a bit of ad-hoc Ruby:

```
$ ruby -r ./lib/objectspace/stats -r ./allocation
stats = ObjectSpace::Stats.new { MyClass.new.my_method }
puts stats.allocations(alias_paths: true).to_text
^D
    sourcefile       sourceline  class_path  method_id  memsize   class
-------------------  ----------  ----------  ---------  -------  -------
<PWD>/allocation.rb           4  MyClass     my_method        0  String
<PWD>/allocation.rb           3  MyClass     my_method      192  Hash
<PWD>/allocation.rb           3  MyClass     my_method        0  String
<PWD>/allocation.rb           3  MyClass     my_method        0  String
<PWD>/allocation.rb           3  MyClass     my_method        0  String
-                             1  Class       new              0  MyClass
```

(I've used `alias_paths: true` above for readability. This way, the `sourcefile`
column is not crazy long, using the full file path on my filesystem.)

(This full example is found in `examples/trace_my_class_raw.rb`)

We can also group allocations by one or more attributes, and get an aggregate
count. Below, we group allocations by source file, source line, and class:

```
$ ruby -r ./lib/objectspace/stats -r ./allocation
stats = ObjectSpace::Stats.new { MyClass.new.my_method }
puts stats.allocations(alias_paths: true).group_by(:sourcefile, :sourceline, :class).to_text
^D
    sourcefile       sourceline   class   count
-------------------  ----------  -------  -----
<PWD>/allocation.rb           4  String       1
<PWD>/allocation.rb           3  Hash         1
<PWD>/allocation.rb           3  String       3
-                             1  MyClass      1
```

(This full example is found in `examples/trace_my_class_group_by.rb`)


More on `trace_object_allocations()`
---------------------------------------------

To start at the beginning: Ruby 2.1 will be released with a new feature that
enables one to trace object allocations. Through
`ObjectSpace.trace_object_allocations`, one can trace the following properties
for any new object allocation:

* source file
* source line
* class path
* method ID
* generation

Let's see this in action:

```
$ cat examples/trace_object_allocations.rb
require 'objspace'

ObjectSpace.trace_object_allocations do
  a = [2,3,5,7,11,13,17,19,23,29,31]
  puts ObjectSpace.allocation_sourcefile(a)
  puts ObjectSpace.allocation_sourceline(a)
end
$ ruby ./examples/trace_object_allocations.rb
allocations.rb
4
```

`ObjectSpace.trace_object_allocations` was designed so as to not reduce the
performance of regular operations. Because of this, the power of
`trace_object_allocations()` is very limited in a few ways:

* The methods that retrieve allocation information (`allocation_sourcefile`,
  etc) are not available outside `trace_object_allocations()`.
* By the same token, you cannot trace any allocations that occur outside of the
  block passed to `trace_object_allocations()`. Because of these limitations, a
  richer API is necessary in order to take advantage of these new
  allocation-tracing features.  This gem provides such an API. Let's look at
  more examples:

Example from the specs
----------------------

```ruby
existing_array = [1,2,3,4,5]

stats = ObjectSpace::Stats.new do
  new_string     = "stringy string"
  another_string = "another string"
  an_array       = [1,1,2,3,5,8,13,21,34,55]
  a_foreign_string = allocate_a_string_from_spec_helper
end

results = stats.allocations.group_by(:@sourcefile, :class).to_a
```

We've grouped all of the traced allocations by the **source file** that the
allocation occurred in, and the **class of the object** that was allocated. The
list of allocations can be "transformed" in a number of ways (including
the above `#group_by`), so the transformations must be ultimately resolved by calling
`#to_a` (similar to ActiveRecord relations).  The result is the following Hash of (sourcefile, class) tuple keys and
ObjectSpace::Stats::Allocation values:

```ruby
{
  [".../spec/spec_helper.rb", String]
    =>
  [#<ObjectSpace::Stats::Allocation:0x007f132ac3f160
    @object="a string from spec_helper",
    @memsize=0,
    @sourcefile=".../spec/spec_helper.rb",
    @sourceline=14,
    @class_path="Object",
    @method_id=:allocate_a_string_from_spec_helper>
  ],

  [".../spec/objectspace_stats_spec.rb", Array]
    =>
  [#<ObjectSpace::Stats::Allocation:0x007f132ac3e968
    @object=[1, 1, 2, 3, 5, 8, 13, 21, 34, 55],
    @memsize=80,
    @sourcefile=".../spec/objectspace_stats_spec.rb",
    @sourceline=78,
    @class_path=nil,
    @method_id=nil>
  ],

  [".../spec/objectspace_stats_spec.rb", String]
    =>
  [ #<ObjectSpace::Stats::Allocation:0x007f132ac3e0d0
      @object="another string",
      @memsize=0,
      @sourcefile=".../spec/objectspace_stats_spec.rb",
      @sourceline=77,
      @class_path=nil,
      @method_id=nil>,
    #<ObjectSpace::Stats::Allocation:0x007f132ac3d838
      @object="stringy string",
      @memsize=0,
      @sourcefile=".../spec/objectspace_stats_spec.rb",
      @sourceline=76,
      @class_path=nil,
      @method_id=nil>
  ]
}
```

(I've manually inserted the ellipses.)

You can see that there are three different groups:

* `[spec_helper.rb, String]`
* `[objectspace_stats_spec.rb, Array]`
* `[object_space_stats.rb, String]`

Only one allocation belongs to each of the first two groups, and two allocations
make up the second group.

A little slower
---------------

Let's look at this example a little slower. Firstly, let's look at how we
collect object allocations using ObjectSpace Stats:

```ruby
stats = ObjectSpace::Stats.new do
  new_string     = "stringy string"
  another_string = "another string"
  an_array       = [1,1,2,3,5,8,13,21,34,55]
  a_foreign_string = allocate_a_string_from_spec_helper
end
```

Stats are collected by running a block through `ObjectSpace::Stats.new`. This is
largely just a thin wrapper around `trace_object_allocations()`. You are handed
back your new ObjectSpace::Stats, which essentially just holds all of the
allocation information, accessible via `#allocations`. Let's look at the next
line to see how we can pull useful information out:

```ruby
  results = stats.allocations.group_by(:@sourcefile, :class).to_a
```

If you are used to chaining ActiveRecord relations, some of this might look
familiar to you: `stats.allocations` will hand you back an {AllocationsProxy}
object, designed to hold the various transformations that you wish to run the
allocations through.  AllocationsProxy uses the Command pattern to store up
transformations before they will actually be applied. In this example, we only
make one transformation: `group_by(:@sourcefile, :class)`. Since more
transformations might be called, this method just returns the same
AllocationsProxy object, so that transformations can be chained. The final call
that will execute the transformations is `#to_a` (aliased to `#all`, just like
ActiveRecord).

Psych Example
-------------

Let's look at an example with more varied allocations, using Ruby's Psych:

```ruby
stats = ObjectSpace::Stats.new do
  y = YAML.dump(["one string", "two string"]) # lots of objects from Rbconfig::CONFIG["rubylibdir"]
end

stats.allocations.group_by(:@sourcefile, :class).all.keys #=>

[
  [".../spec/objectspace_stats_spec.rb", Array],
  [".../spec/objectspace_stats_spec.rb", String],
  ["<RUBYLIBDIR>/psych/visitors/yaml_tree.rb", String],
  ["<RUBYLIBDIR>/psych/visitors/yaml_tree.rb", MatchData],
  ["<RUBYLIBDIR>/psych/visitors/yaml_tree.rb", Array],
  ["<RUBYLIBDIR>/psych/visitors/yaml_tree.rb", Method],
  ["<RUBYLIBDIR>/psych/nodes/node.rb", Array], ["(eval)", Psych::Nodes::Sequence],
  ["<RUBYLIBDIR>/psych/tree_builder.rb", Psych::Nodes::Document],
  ["<RUBYLIBDIR>/psych.rb", Hash], ["<RUBYLIBDIR>/psych/visitors/yaml_tree.rb", Psych::TreeBuilder],
  ["<RUBYLIBDIR>/psych/tree_builder.rb", Psych::Nodes::Stream],
  ["<RUBYLIBDIR>/psych/visitors/yaml_tree.rb", Proc],
  ["<RUBYLIBDIR>/psych/tree_builder.rb", Array],
  ["<RUBYLIBDIR>/psych/visitors/yaml_tree.rb", RubyVM::Env],
  ["<RUBYLIBDIR>/psych/visitors/yaml_tree.rb", Hash],
  ["<RUBYLIBDIR>/psych/visitors/yaml_tree.rb", Psych::Visitors::YAMLTree::Registrar],
  ["<RUBYLIBDIR>/psych/visitors/yaml_tree.rb", Psych::Visitors::YAMLTree],
  ["<RUBYLIBDIR>/psych/scalar_scanner.rb", Hash],
  ["<RUBYLIBDIR>/psych/visitors/yaml_tree.rb", Psych::ScalarScanner],
  ["<RUBYLIBDIR>/psych/class_loader.rb", Hash],
  ["<RUBYLIBDIR>/psych/visitors/yaml_tree.rb", Psych::ClassLoader],
  ["<RUBYLIBDIR>/psych/visitors/emitter.rb", Psych::Emitter],
  ["<RUBYLIBDIR>/psych/visitors/emitter.rb", Array],
  ["<RUBYLIBDIR>/psych/nodes/node.rb", Psych::Visitors::Emitter],
  ["<RUBYLIBDIR>/psych/nodes/node.rb", StringIO],
  ["<RUBYLIBDIR>/psych/nodes/node.rb", String],
  ["<RUBYLIBDIR>/psych/tree_builder.rb", Psych::Nodes::Scalar],
  ["<RUBYLIBDIR>/psych/scalar_scanner.rb", String],
  ["<RUBYLIBDIR>/psych/scalar_scanner.rb", MatchData],
  ["<RUBYLIBDIR>/psych/visitors/emitter.rb", String]
]
```

The API
=======

So what methods are available on that AllocationsProxy thing? So far, the API
consists of:

* `#group_by`
* `#from` takes one String argument, which will matched against the
  allocation filename.
* `#not_from` is the opposite of `#from`.
* `#from_pwd` will filter the allocations down to those originating from `pwd`
  (e.g. allocations originating from "my project")
* `#where` accepts a hash of faux attribute keys. For example,

  ```ruby
  allocations.where(class: String)
  ```

  It does not yet accept lambdas as values, which _would_ enable
  ActiveRecord-4-like calls, like

  ```ruby
  allocations.where(class: Array, size: ->(size) { size > 10 }
  ```
* `#bytes`, which has an inconsistent definition, I think... TODO

What are faux attributes?
-------------------------

Valid values for `#group_by` and `#where` include:
* instance variables on each `Allocation`. These include `:sourcefile`,
  `:sourceline`, etc.
* methods available on the objects that were allocated. These include things
  like `:class`, or even `:size` if you know you only have objects that respond
  to `:size`.
* Allocation helper methods that return something special about the allocated
  object. Right now this just includes `:class_plus`.

I'm calling these things that you can group by or filter by, "faux attributes."

What is `class_plus`?
---------------------

References
==========

This new feature was inspired by work that @tmm1 did at GitHub, as
described in
[this post](https://github.com/blog/1489-hey-judy-don-t-make-it-bad). It was
proposed as a feature in Ruby Core by @tmm1 in
[Ruby issue #8107](http://bugs.ruby-lang.org/issues/8107), and @ko1 wrote it
into MRI. He introduces the feature in his Ruby Kaigi 2013 presentation, on
slides 29 through 33
[[pdf](http://www.atdot.net/~ko1/activities/RubyKaigi2013-ko1.pdf)].
